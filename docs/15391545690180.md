# JAVA内存区域 --（2）对象创建

JVM 在遇到一条 new 指令时，是如何为其分配内存空间并初始化的呢？
笔者将流程画成了一个简单的流程图：
![未命名文件](media/15391545690180/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)
这里我们先略过第二步的类加载机制，主要讲述后面 4 个步骤。

* 下文马上会拿一节介绍 JVM 是如何为对象分配内存的。

* 虚拟机讲分配到的空间初始化为零值
 保证了对象的实例字段不赋值的时候访问到的是自卸字段所对应的零值（对象是null）。

* 设置对象头
JVM 对对象进行必要的设置，对象是哪个类的实例，如何才能找到对象的元数据信息，对象的 hashCode，对象的 GC 分代年龄等信息，都会存放到对象头中。具体对象头的内容在下文中会介绍

* 执行 `<init>` 方法进行初始化步骤。


### 分配内存

#### 确认内存位置
分配对象的过程中，需要为对象划分足够大的内存空间，而如何从 Java 堆中找到合适大小的空间，通常用以下两种方法：
* 指针碰撞（Bump the Pointer）
保证 Java 堆中内存时绝对规整的，所有用过内存和空闲的内存各占一边，中间放着一个指针作为分界点的指示器。而分配内存的过程就是将指示指针向空闲空间移动对象大小的距离。

* 空闲列表（Free List）
JVM 维护一个列表，记录内存块的使用情况，分配过程则是在列表中找到一块足够大的空间分配给对象实例，并更新表上记录。

而以上两种方法由虚拟机的 Java 堆是否规整决定，也就是由 GC 算法是否具备压缩整理的能力决定。

#### 确保线程安全
多个线程在创建对象时，为了保证分配内存空间的动作是同步处理的：

* CAS 配上失败重试的方式保证更新操作的原子性

* 本地线程分配缓冲（Thread Local Allocation Buffer）
每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer）。每个线程在各自 TLAB 上分配内存。只有在 TLAB 用完之后并分配新的 TLAB 时，才需要同步。


### 对象的内存分布
在 HotSpot 虚拟机中，对象的内存储存布局可以分为3个区域： 对象头（Header）、 实例数据（Instance Data）、 对齐填充（Padding）。

### 对象头（Header）
对象头包含两部分的信息：

* 存储自身的运行时数据
如 HashCode、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等
这部分数据在 32 位和 64 位虚拟机中分别占有 32bit 和 64bit ，官方称为“Mark Word”。

* 存储类型指针
即对象指向它的类元数据的指针，JVM 通过这个指针来确认这个对象是哪个类的实例。

如果对象是一个 Java 数组，那在对象头中还需要一块用于记录数组长度的数据。
	
### 实例数据（Instance Data）
实例数据部分是对象真正有效的信息，也就是在程序中定义的各种类型的字段内容。
这个存储顺序还会受到虚拟机的分配策略参数和字段在 Java 源码中定义顺序影响。HotSpot 默认的分配策略为 longs / doubles、ints、shouts / chars、bytes / booleans、oops(Ordinary Object Pointers),即把相同大小的字段分配到一起。

### 对齐填充（Padding）

对齐填充并不是必须存在的，也没有特别含义，仅仅起到占位符的作用。因为 HotSpot 的自动内存管理系统要求对象的起址位置必须是8字节的整数倍。

### 对象的访问定位
我们通过栈上的 reference 数据来操作堆上的具体对象。目前通过主流的方式 _句柄_ 和 _直接指针_ 去定位、访问堆中对象的具体位置。

**句柄**：Java 堆中将划出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据地址和类型数据的地址。


![0f9ee0af-bc2d-4e26-a5ad-19c833e66e89.png](http://upload-images.jianshu.io/upload_images/4894808-4367b9d6699f2ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**直接指针访问**：在 Java 堆中对象放置了访问类型数据的相关地址，而 reference 直接指向对象实例数据。

![293EC415-7099-4BBE-9991-2849B5A43D73.png](http://upload-images.jianshu.io/upload_images/4894808-78010d19b24fc39a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 使用句柄的优势：
在对象被移动时（GC 中移动时十分普遍的行为），只会改变句柄的实例数据指针，而不会修改 reference 本身。
* 直接访问的优势：
节省了一次指针定位的时间开销，由于对象访问在 Java（或者说所有面向对象的语言）中是非常频繁的。HotSpot 使用的就是直接指针访问。